// Package bridge implements the Azure ARM Bridge service API version 1.0.
//
//
package bridge

// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
    "context"
    "github.com/Azure/go-autorest/autorest"
    "github.com/Azure/go-autorest/autorest/azure"
    "github.com/Azure/go-autorest/autorest/validation"
    "github.com/Azure/go-autorest/tracing"
    "net/http"
)

const (
// DefaultBaseURI is the default URI used for the service Bridge
DefaultBaseURI = "")

// BaseClient is the base client for Bridge.
type BaseClient struct {
    autorest.Client
    BaseURI string
}

// New creates an instance of the BaseClient client.
func New()BaseClient {
    return NewWithBaseURI(DefaultBaseURI, )
}

// NewWithBaseURI creates an instance of the BaseClient client using a custom endpoint.  Use this when interacting with
// an Azure cloud that uses a non-standard base URI (sovereign clouds, Azure stack).
func NewWithBaseURI(baseURI string, ) BaseClient {
    return BaseClient{
        Client: autorest.NewClientWithUserAgent(UserAgent()),
        BaseURI: baseURI,
    }
}

    // CreateOrUpdateC2DMessageSubscription when the device receives a new C2D message from IoTHub, the service will send
    // an event to the desired callback URL.
    //
    // Example event:
    // {
    // "eventType": "string",
    // "deviceId": "string",
    // "deviceReceivedAt": "2020-12-04T01:06:14.251Z",
    // "messageBody": {},
    // "properties": {
    // "prop1": "string",
    // "prop2": "string",
    // },
    // "messageId": "string",
    // "expirtyTimeUtC": "2020-12-04T01:06:14.251Z"
    // }
    //
    // The response status code of the callback URL will determine how the service will acknowledge a message:
    // - Response code between 200 and 299: the service will complete the message.
    // - Response code between 400 and 499: the service will reject the message.
    // - Any other response status: the service will abandon the message, causing IotHub to redeliver it.
    //
    // For a detailed overview of C2D messages, see
    // https://docs.microsoft.com/en-us/azure/iot-hub/iot-hub-devguide-messages-c2d.
    func (client BaseClient) CreateOrUpdateC2DMessageSubscription(ctx context.Context, deviceID string, body *SubscriptionCreateOrUpdateBody) (result DeviceSubscriptionWithStatus, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.CreateOrUpdateC2DMessageSubscription")
            defer func() {
                sc := -1
            if result.Response.Response != nil {
            sc = result.Response.Response.StatusCode
            }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            if err := validation.Validate([]validation.Validation{
            { TargetValue: body,
             Constraints: []validation.Constraint{	{Target: "body", Name: validation.Null, Rule: false ,
            Chain: []validation.Constraint{	{Target: "body.CallbackURL", Name: validation.Null, Rule: true, Chain: nil },
            }}}}}); err != nil {
            return result, validation.NewError("bridge.BaseClient", "CreateOrUpdateC2DMessageSubscription", err.Error())
            }

            req, err := client.CreateOrUpdateC2DMessageSubscriptionPreparer(ctx, deviceID, body)
        if err != nil {
        err = autorest.NewErrorWithError(err, "bridge.BaseClient", "CreateOrUpdateC2DMessageSubscription", nil , "Failure preparing request")
        return
        }

            resp, err := client.CreateOrUpdateC2DMessageSubscriptionSender(req)
            if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "bridge.BaseClient", "CreateOrUpdateC2DMessageSubscription", resp, "Failure sending request")
            return
            }

            result, err = client.CreateOrUpdateC2DMessageSubscriptionResponder(resp)
            if err != nil {
            err = autorest.NewErrorWithError(err, "bridge.BaseClient", "CreateOrUpdateC2DMessageSubscription", resp, "Failure responding to request")
            return
            }

        return
    }

        // CreateOrUpdateC2DMessageSubscriptionPreparer prepares the CreateOrUpdateC2DMessageSubscription request.
        func (client BaseClient) CreateOrUpdateC2DMessageSubscriptionPreparer(ctx context.Context, deviceID string, body *SubscriptionCreateOrUpdateBody) (*http.Request, error) {
            pathParameters := map[string]interface{} {
            "deviceId": autorest.Encode("path",deviceID),
            }

        preparer := autorest.CreatePreparer(
    autorest.AsContentType("application/json; charset=utf-8"),
    autorest.AsPut(),
    autorest.WithBaseURL(client.BaseURI),
    autorest.WithPathParameters("/devices/{deviceId}/DeviceBound/sub",pathParameters))
            if body != nil {
            preparer = autorest.DecoratePreparer(preparer,
            autorest.WithJSON(body))
            }
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // CreateOrUpdateC2DMessageSubscriptionSender sends the CreateOrUpdateC2DMessageSubscription request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) CreateOrUpdateC2DMessageSubscriptionSender(req *http.Request) (*http.Response, error) {
                    return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                    }

        // CreateOrUpdateC2DMessageSubscriptionResponder handles the response to the CreateOrUpdateC2DMessageSubscription request. The method always
        // closes the http.Response Body.
        func (client BaseClient) CreateOrUpdateC2DMessageSubscriptionResponder(resp *http.Response) (result DeviceSubscriptionWithStatus, err error) {
                err = autorest.Respond(
                resp,
                azure.WithErrorUnlessStatusCode(http.StatusOK),
                autorest.ByUnmarshallingJSON(&result),
                autorest.ByClosing())
                result.Response = autorest.Response{Response: resp}
                return
        }

    // CreateOrUpdateConnectionStatusSubscription when the internal connection status of a device changes, the service will
    // send an event to the desired callback URL.
    //
    // Example event:
    // {
    // "eventType": "string",
    // "deviceId": "string",
    // "deviceReceivedAt": "2020-12-04T01:06:14.251Z",
    // "status": "string",
    // "reason": "string"
    // }
    //
    // For a detailed description of each status, see
    // https://docs.microsoft.com/en-us/dotnet/api/microsoft.azure.devices.client.connectionstatus?view=azure-dotnet.
    func (client BaseClient) CreateOrUpdateConnectionStatusSubscription(ctx context.Context, deviceID string, body *SubscriptionCreateOrUpdateBody) (result DeviceSubscription, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.CreateOrUpdateConnectionStatusSubscription")
            defer func() {
                sc := -1
            if result.Response.Response != nil {
            sc = result.Response.Response.StatusCode
            }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            if err := validation.Validate([]validation.Validation{
            { TargetValue: body,
             Constraints: []validation.Constraint{	{Target: "body", Name: validation.Null, Rule: false ,
            Chain: []validation.Constraint{	{Target: "body.CallbackURL", Name: validation.Null, Rule: true, Chain: nil },
            }}}}}); err != nil {
            return result, validation.NewError("bridge.BaseClient", "CreateOrUpdateConnectionStatusSubscription", err.Error())
            }

            req, err := client.CreateOrUpdateConnectionStatusSubscriptionPreparer(ctx, deviceID, body)
        if err != nil {
        err = autorest.NewErrorWithError(err, "bridge.BaseClient", "CreateOrUpdateConnectionStatusSubscription", nil , "Failure preparing request")
        return
        }

            resp, err := client.CreateOrUpdateConnectionStatusSubscriptionSender(req)
            if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "bridge.BaseClient", "CreateOrUpdateConnectionStatusSubscription", resp, "Failure sending request")
            return
            }

            result, err = client.CreateOrUpdateConnectionStatusSubscriptionResponder(resp)
            if err != nil {
            err = autorest.NewErrorWithError(err, "bridge.BaseClient", "CreateOrUpdateConnectionStatusSubscription", resp, "Failure responding to request")
            return
            }

        return
    }

        // CreateOrUpdateConnectionStatusSubscriptionPreparer prepares the CreateOrUpdateConnectionStatusSubscription request.
        func (client BaseClient) CreateOrUpdateConnectionStatusSubscriptionPreparer(ctx context.Context, deviceID string, body *SubscriptionCreateOrUpdateBody) (*http.Request, error) {
            pathParameters := map[string]interface{} {
            "deviceId": autorest.Encode("path",deviceID),
            }

        preparer := autorest.CreatePreparer(
    autorest.AsContentType("application/json; charset=utf-8"),
    autorest.AsPut(),
    autorest.WithBaseURL(client.BaseURI),
    autorest.WithPathParameters("/devices/{deviceId}/ConnectionStatus/sub",pathParameters))
            if body != nil {
            preparer = autorest.DecoratePreparer(preparer,
            autorest.WithJSON(body))
            }
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // CreateOrUpdateConnectionStatusSubscriptionSender sends the CreateOrUpdateConnectionStatusSubscription request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) CreateOrUpdateConnectionStatusSubscriptionSender(req *http.Request) (*http.Response, error) {
                    return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                    }

        // CreateOrUpdateConnectionStatusSubscriptionResponder handles the response to the CreateOrUpdateConnectionStatusSubscription request. The method always
        // closes the http.Response Body.
        func (client BaseClient) CreateOrUpdateConnectionStatusSubscriptionResponder(resp *http.Response) (result DeviceSubscription, err error) {
                err = autorest.Respond(
                resp,
                azure.WithErrorUnlessStatusCode(http.StatusOK),
                autorest.ByUnmarshallingJSON(&result),
                autorest.ByClosing())
                result.Response = autorest.Response{Response: resp}
                return
        }

    // CreateOrUpdateDesiredPropertiesSubscription when the device receives a new desired property change from IoTHub, the
    // service will send an event to the desired callback URL.
    //
    // Example event:
    // {
    // "eventType": "string",
    // "deviceId": "string",
    // "deviceReceivedAt": "2020-12-04T01:06:14.251Z",
    // "desiredProperties": {
    // "prop1": "string",
    // "prop2": 12,
    // "prop3": {},
    // }
    // }
    // .
    func (client BaseClient) CreateOrUpdateDesiredPropertiesSubscription(ctx context.Context, deviceID string, body *SubscriptionCreateOrUpdateBody) (result DeviceSubscriptionWithStatus, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.CreateOrUpdateDesiredPropertiesSubscription")
            defer func() {
                sc := -1
            if result.Response.Response != nil {
            sc = result.Response.Response.StatusCode
            }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            if err := validation.Validate([]validation.Validation{
            { TargetValue: body,
             Constraints: []validation.Constraint{	{Target: "body", Name: validation.Null, Rule: false ,
            Chain: []validation.Constraint{	{Target: "body.CallbackURL", Name: validation.Null, Rule: true, Chain: nil },
            }}}}}); err != nil {
            return result, validation.NewError("bridge.BaseClient", "CreateOrUpdateDesiredPropertiesSubscription", err.Error())
            }

            req, err := client.CreateOrUpdateDesiredPropertiesSubscriptionPreparer(ctx, deviceID, body)
        if err != nil {
        err = autorest.NewErrorWithError(err, "bridge.BaseClient", "CreateOrUpdateDesiredPropertiesSubscription", nil , "Failure preparing request")
        return
        }

            resp, err := client.CreateOrUpdateDesiredPropertiesSubscriptionSender(req)
            if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "bridge.BaseClient", "CreateOrUpdateDesiredPropertiesSubscription", resp, "Failure sending request")
            return
            }

            result, err = client.CreateOrUpdateDesiredPropertiesSubscriptionResponder(resp)
            if err != nil {
            err = autorest.NewErrorWithError(err, "bridge.BaseClient", "CreateOrUpdateDesiredPropertiesSubscription", resp, "Failure responding to request")
            return
            }

        return
    }

        // CreateOrUpdateDesiredPropertiesSubscriptionPreparer prepares the CreateOrUpdateDesiredPropertiesSubscription request.
        func (client BaseClient) CreateOrUpdateDesiredPropertiesSubscriptionPreparer(ctx context.Context, deviceID string, body *SubscriptionCreateOrUpdateBody) (*http.Request, error) {
            pathParameters := map[string]interface{} {
            "deviceId": autorest.Encode("path",deviceID),
            }

        preparer := autorest.CreatePreparer(
    autorest.AsContentType("application/json; charset=utf-8"),
    autorest.AsPut(),
    autorest.WithBaseURL(client.BaseURI),
    autorest.WithPathParameters("/devices/{deviceId}/Twin/properties/desired/sub",pathParameters))
            if body != nil {
            preparer = autorest.DecoratePreparer(preparer,
            autorest.WithJSON(body))
            }
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // CreateOrUpdateDesiredPropertiesSubscriptionSender sends the CreateOrUpdateDesiredPropertiesSubscription request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) CreateOrUpdateDesiredPropertiesSubscriptionSender(req *http.Request) (*http.Response, error) {
                    return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                    }

        // CreateOrUpdateDesiredPropertiesSubscriptionResponder handles the response to the CreateOrUpdateDesiredPropertiesSubscription request. The method always
        // closes the http.Response Body.
        func (client BaseClient) CreateOrUpdateDesiredPropertiesSubscriptionResponder(resp *http.Response) (result DeviceSubscriptionWithStatus, err error) {
                err = autorest.Respond(
                resp,
                azure.WithErrorUnlessStatusCode(http.StatusOK),
                autorest.ByUnmarshallingJSON(&result),
                autorest.ByClosing())
                result.Response = autorest.Response{Response: resp}
                return
        }

    // CreateOrUpdateMethodsSubscription when the device receives a direct method invocation from IoTHub, the service will
    // send an event to the desired callback URL.
    //
    // Example event:
    // {
    // "eventType": "string",
    // "deviceId": "string",
    // "deviceReceivedAt": "2020-12-04T01:06:14.251Z",
    // "methodName": "string",
    // "requestData": {}
    // }
    //
    // The callback may return an optional response body, which will be sent to IoTHub as the method response:
    //
    // Example callback response:
    // {
    // "status": 200,
    // "payload": {}
    // }
    // .
    func (client BaseClient) CreateOrUpdateMethodsSubscription(ctx context.Context, deviceID string, body *SubscriptionCreateOrUpdateBody) (result DeviceSubscriptionWithStatus, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.CreateOrUpdateMethodsSubscription")
            defer func() {
                sc := -1
            if result.Response.Response != nil {
            sc = result.Response.Response.StatusCode
            }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            if err := validation.Validate([]validation.Validation{
            { TargetValue: body,
             Constraints: []validation.Constraint{	{Target: "body", Name: validation.Null, Rule: false ,
            Chain: []validation.Constraint{	{Target: "body.CallbackURL", Name: validation.Null, Rule: true, Chain: nil },
            }}}}}); err != nil {
            return result, validation.NewError("bridge.BaseClient", "CreateOrUpdateMethodsSubscription", err.Error())
            }

            req, err := client.CreateOrUpdateMethodsSubscriptionPreparer(ctx, deviceID, body)
        if err != nil {
        err = autorest.NewErrorWithError(err, "bridge.BaseClient", "CreateOrUpdateMethodsSubscription", nil , "Failure preparing request")
        return
        }

            resp, err := client.CreateOrUpdateMethodsSubscriptionSender(req)
            if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "bridge.BaseClient", "CreateOrUpdateMethodsSubscription", resp, "Failure sending request")
            return
            }

            result, err = client.CreateOrUpdateMethodsSubscriptionResponder(resp)
            if err != nil {
            err = autorest.NewErrorWithError(err, "bridge.BaseClient", "CreateOrUpdateMethodsSubscription", resp, "Failure responding to request")
            return
            }

        return
    }

        // CreateOrUpdateMethodsSubscriptionPreparer prepares the CreateOrUpdateMethodsSubscription request.
        func (client BaseClient) CreateOrUpdateMethodsSubscriptionPreparer(ctx context.Context, deviceID string, body *SubscriptionCreateOrUpdateBody) (*http.Request, error) {
            pathParameters := map[string]interface{} {
            "deviceId": autorest.Encode("path",deviceID),
            }

        preparer := autorest.CreatePreparer(
    autorest.AsContentType("application/json; charset=utf-8"),
    autorest.AsPut(),
    autorest.WithBaseURL(client.BaseURI),
    autorest.WithPathParameters("/devices/{deviceId}/Methods/sub",pathParameters))
            if body != nil {
            preparer = autorest.DecoratePreparer(preparer,
            autorest.WithJSON(body))
            }
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // CreateOrUpdateMethodsSubscriptionSender sends the CreateOrUpdateMethodsSubscription request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) CreateOrUpdateMethodsSubscriptionSender(req *http.Request) (*http.Response, error) {
                    return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                    }

        // CreateOrUpdateMethodsSubscriptionResponder handles the response to the CreateOrUpdateMethodsSubscription request. The method always
        // closes the http.Response Body.
        func (client BaseClient) CreateOrUpdateMethodsSubscriptionResponder(resp *http.Response) (result DeviceSubscriptionWithStatus, err error) {
                err = autorest.Respond(
                resp,
                azure.WithErrorUnlessStatusCode(http.StatusOK),
                autorest.ByUnmarshallingJSON(&result),
                autorest.ByClosing())
                result.Response = autorest.Response{Response: resp}
                return
        }

    // DeleteC2DMessageSubscription sends the delete c2d message subscription request.
    func (client BaseClient) DeleteC2DMessageSubscription(ctx context.Context, deviceID string) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.DeleteC2DMessageSubscription")
            defer func() {
                sc := -1
            if result.Response != nil {
            sc = result.Response.StatusCode
            }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
        req, err := client.DeleteC2DMessageSubscriptionPreparer(ctx, deviceID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "bridge.BaseClient", "DeleteC2DMessageSubscription", nil , "Failure preparing request")
        return
        }

            resp, err := client.DeleteC2DMessageSubscriptionSender(req)
            if err != nil {
            result.Response = resp
            err = autorest.NewErrorWithError(err, "bridge.BaseClient", "DeleteC2DMessageSubscription", resp, "Failure sending request")
            return
            }

            result, err = client.DeleteC2DMessageSubscriptionResponder(resp)
            if err != nil {
            err = autorest.NewErrorWithError(err, "bridge.BaseClient", "DeleteC2DMessageSubscription", resp, "Failure responding to request")
            return
            }

        return
    }

        // DeleteC2DMessageSubscriptionPreparer prepares the DeleteC2DMessageSubscription request.
        func (client BaseClient) DeleteC2DMessageSubscriptionPreparer(ctx context.Context, deviceID string) (*http.Request, error) {
            pathParameters := map[string]interface{} {
            "deviceId": autorest.Encode("path",deviceID),
            }

        preparer := autorest.CreatePreparer(
    autorest.AsDelete(),
    autorest.WithBaseURL(client.BaseURI),
    autorest.WithPathParameters("/devices/{deviceId}/DeviceBound/sub",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // DeleteC2DMessageSubscriptionSender sends the DeleteC2DMessageSubscription request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) DeleteC2DMessageSubscriptionSender(req *http.Request) (*http.Response, error) {
                    return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                    }

        // DeleteC2DMessageSubscriptionResponder handles the response to the DeleteC2DMessageSubscription request. The method always
        // closes the http.Response Body.
        func (client BaseClient) DeleteC2DMessageSubscriptionResponder(resp *http.Response) (result autorest.Response, err error) {
                err = autorest.Respond(
                resp,
                azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNoContent),
                autorest.ByClosing())
                result.Response = resp
                return
        }

    // DeleteConnectionStatusSubscription sends the delete connection status subscription request.
    func (client BaseClient) DeleteConnectionStatusSubscription(ctx context.Context, deviceID string) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.DeleteConnectionStatusSubscription")
            defer func() {
                sc := -1
            if result.Response != nil {
            sc = result.Response.StatusCode
            }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
        req, err := client.DeleteConnectionStatusSubscriptionPreparer(ctx, deviceID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "bridge.BaseClient", "DeleteConnectionStatusSubscription", nil , "Failure preparing request")
        return
        }

            resp, err := client.DeleteConnectionStatusSubscriptionSender(req)
            if err != nil {
            result.Response = resp
            err = autorest.NewErrorWithError(err, "bridge.BaseClient", "DeleteConnectionStatusSubscription", resp, "Failure sending request")
            return
            }

            result, err = client.DeleteConnectionStatusSubscriptionResponder(resp)
            if err != nil {
            err = autorest.NewErrorWithError(err, "bridge.BaseClient", "DeleteConnectionStatusSubscription", resp, "Failure responding to request")
            return
            }

        return
    }

        // DeleteConnectionStatusSubscriptionPreparer prepares the DeleteConnectionStatusSubscription request.
        func (client BaseClient) DeleteConnectionStatusSubscriptionPreparer(ctx context.Context, deviceID string) (*http.Request, error) {
            pathParameters := map[string]interface{} {
            "deviceId": autorest.Encode("path",deviceID),
            }

        preparer := autorest.CreatePreparer(
    autorest.AsDelete(),
    autorest.WithBaseURL(client.BaseURI),
    autorest.WithPathParameters("/devices/{deviceId}/ConnectionStatus/sub",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // DeleteConnectionStatusSubscriptionSender sends the DeleteConnectionStatusSubscription request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) DeleteConnectionStatusSubscriptionSender(req *http.Request) (*http.Response, error) {
                    return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                    }

        // DeleteConnectionStatusSubscriptionResponder handles the response to the DeleteConnectionStatusSubscription request. The method always
        // closes the http.Response Body.
        func (client BaseClient) DeleteConnectionStatusSubscriptionResponder(resp *http.Response) (result autorest.Response, err error) {
                err = autorest.Respond(
                resp,
                azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNoContent),
                autorest.ByClosing())
                result.Response = resp
                return
        }

    // DeleteDesiredPropertiesSubscription sends the delete desired properties subscription request.
    func (client BaseClient) DeleteDesiredPropertiesSubscription(ctx context.Context, deviceID string) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.DeleteDesiredPropertiesSubscription")
            defer func() {
                sc := -1
            if result.Response != nil {
            sc = result.Response.StatusCode
            }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
        req, err := client.DeleteDesiredPropertiesSubscriptionPreparer(ctx, deviceID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "bridge.BaseClient", "DeleteDesiredPropertiesSubscription", nil , "Failure preparing request")
        return
        }

            resp, err := client.DeleteDesiredPropertiesSubscriptionSender(req)
            if err != nil {
            result.Response = resp
            err = autorest.NewErrorWithError(err, "bridge.BaseClient", "DeleteDesiredPropertiesSubscription", resp, "Failure sending request")
            return
            }

            result, err = client.DeleteDesiredPropertiesSubscriptionResponder(resp)
            if err != nil {
            err = autorest.NewErrorWithError(err, "bridge.BaseClient", "DeleteDesiredPropertiesSubscription", resp, "Failure responding to request")
            return
            }

        return
    }

        // DeleteDesiredPropertiesSubscriptionPreparer prepares the DeleteDesiredPropertiesSubscription request.
        func (client BaseClient) DeleteDesiredPropertiesSubscriptionPreparer(ctx context.Context, deviceID string) (*http.Request, error) {
            pathParameters := map[string]interface{} {
            "deviceId": autorest.Encode("path",deviceID),
            }

        preparer := autorest.CreatePreparer(
    autorest.AsDelete(),
    autorest.WithBaseURL(client.BaseURI),
    autorest.WithPathParameters("/devices/{deviceId}/Twin/properties/desired/sub",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // DeleteDesiredPropertiesSubscriptionSender sends the DeleteDesiredPropertiesSubscription request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) DeleteDesiredPropertiesSubscriptionSender(req *http.Request) (*http.Response, error) {
                    return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                    }

        // DeleteDesiredPropertiesSubscriptionResponder handles the response to the DeleteDesiredPropertiesSubscription request. The method always
        // closes the http.Response Body.
        func (client BaseClient) DeleteDesiredPropertiesSubscriptionResponder(resp *http.Response) (result autorest.Response, err error) {
                err = autorest.Respond(
                resp,
                azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNoContent),
                autorest.ByClosing())
                result.Response = resp
                return
        }

    // DeleteMethodsSubscription sends the delete methods subscription request.
    func (client BaseClient) DeleteMethodsSubscription(ctx context.Context, deviceID string) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.DeleteMethodsSubscription")
            defer func() {
                sc := -1
            if result.Response != nil {
            sc = result.Response.StatusCode
            }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
        req, err := client.DeleteMethodsSubscriptionPreparer(ctx, deviceID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "bridge.BaseClient", "DeleteMethodsSubscription", nil , "Failure preparing request")
        return
        }

            resp, err := client.DeleteMethodsSubscriptionSender(req)
            if err != nil {
            result.Response = resp
            err = autorest.NewErrorWithError(err, "bridge.BaseClient", "DeleteMethodsSubscription", resp, "Failure sending request")
            return
            }

            result, err = client.DeleteMethodsSubscriptionResponder(resp)
            if err != nil {
            err = autorest.NewErrorWithError(err, "bridge.BaseClient", "DeleteMethodsSubscription", resp, "Failure responding to request")
            return
            }

        return
    }

        // DeleteMethodsSubscriptionPreparer prepares the DeleteMethodsSubscription request.
        func (client BaseClient) DeleteMethodsSubscriptionPreparer(ctx context.Context, deviceID string) (*http.Request, error) {
            pathParameters := map[string]interface{} {
            "deviceId": autorest.Encode("path",deviceID),
            }

        preparer := autorest.CreatePreparer(
    autorest.AsDelete(),
    autorest.WithBaseURL(client.BaseURI),
    autorest.WithPathParameters("/devices/{deviceId}/Methods/sub",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // DeleteMethodsSubscriptionSender sends the DeleteMethodsSubscription request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) DeleteMethodsSubscriptionSender(req *http.Request) (*http.Response, error) {
                    return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                    }

        // DeleteMethodsSubscriptionResponder handles the response to the DeleteMethodsSubscription request. The method always
        // closes the http.Response Body.
        func (client BaseClient) DeleteMethodsSubscriptionResponder(resp *http.Response) (result autorest.Response, err error) {
                err = autorest.Respond(
                resp,
                azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNoContent),
                autorest.ByClosing())
                result.Response = resp
                return
        }

    // GetC2DMessageSubscription sends the get c2d message subscription request.
    func (client BaseClient) GetC2DMessageSubscription(ctx context.Context, deviceID string) (result DeviceSubscriptionWithStatus, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetC2DMessageSubscription")
            defer func() {
                sc := -1
            if result.Response.Response != nil {
            sc = result.Response.Response.StatusCode
            }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
        req, err := client.GetC2DMessageSubscriptionPreparer(ctx, deviceID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "bridge.BaseClient", "GetC2DMessageSubscription", nil , "Failure preparing request")
        return
        }

            resp, err := client.GetC2DMessageSubscriptionSender(req)
            if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "bridge.BaseClient", "GetC2DMessageSubscription", resp, "Failure sending request")
            return
            }

            result, err = client.GetC2DMessageSubscriptionResponder(resp)
            if err != nil {
            err = autorest.NewErrorWithError(err, "bridge.BaseClient", "GetC2DMessageSubscription", resp, "Failure responding to request")
            return
            }

        return
    }

        // GetC2DMessageSubscriptionPreparer prepares the GetC2DMessageSubscription request.
        func (client BaseClient) GetC2DMessageSubscriptionPreparer(ctx context.Context, deviceID string) (*http.Request, error) {
            pathParameters := map[string]interface{} {
            "deviceId": autorest.Encode("path",deviceID),
            }

        preparer := autorest.CreatePreparer(
    autorest.AsGet(),
    autorest.WithBaseURL(client.BaseURI),
    autorest.WithPathParameters("/devices/{deviceId}/DeviceBound/sub",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetC2DMessageSubscriptionSender sends the GetC2DMessageSubscription request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetC2DMessageSubscriptionSender(req *http.Request) (*http.Response, error) {
                    return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                    }

        // GetC2DMessageSubscriptionResponder handles the response to the GetC2DMessageSubscription request. The method always
        // closes the http.Response Body.
        func (client BaseClient) GetC2DMessageSubscriptionResponder(resp *http.Response) (result DeviceSubscriptionWithStatus, err error) {
                err = autorest.Respond(
                resp,
                azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNotFound),
                autorest.ByUnmarshallingJSON(&result),
                autorest.ByClosing())
                result.Response = autorest.Response{Response: resp}
                return
        }

    // GetConnectionStatusSubscription sends the get connection status subscription request.
    func (client BaseClient) GetConnectionStatusSubscription(ctx context.Context, deviceID string) (result DeviceSubscription, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetConnectionStatusSubscription")
            defer func() {
                sc := -1
            if result.Response.Response != nil {
            sc = result.Response.Response.StatusCode
            }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
        req, err := client.GetConnectionStatusSubscriptionPreparer(ctx, deviceID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "bridge.BaseClient", "GetConnectionStatusSubscription", nil , "Failure preparing request")
        return
        }

            resp, err := client.GetConnectionStatusSubscriptionSender(req)
            if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "bridge.BaseClient", "GetConnectionStatusSubscription", resp, "Failure sending request")
            return
            }

            result, err = client.GetConnectionStatusSubscriptionResponder(resp)
            if err != nil {
            err = autorest.NewErrorWithError(err, "bridge.BaseClient", "GetConnectionStatusSubscription", resp, "Failure responding to request")
            return
            }

        return
    }

        // GetConnectionStatusSubscriptionPreparer prepares the GetConnectionStatusSubscription request.
        func (client BaseClient) GetConnectionStatusSubscriptionPreparer(ctx context.Context, deviceID string) (*http.Request, error) {
            pathParameters := map[string]interface{} {
            "deviceId": autorest.Encode("path",deviceID),
            }

        preparer := autorest.CreatePreparer(
    autorest.AsGet(),
    autorest.WithBaseURL(client.BaseURI),
    autorest.WithPathParameters("/devices/{deviceId}/ConnectionStatus/sub",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetConnectionStatusSubscriptionSender sends the GetConnectionStatusSubscription request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetConnectionStatusSubscriptionSender(req *http.Request) (*http.Response, error) {
                    return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                    }

        // GetConnectionStatusSubscriptionResponder handles the response to the GetConnectionStatusSubscription request. The method always
        // closes the http.Response Body.
        func (client BaseClient) GetConnectionStatusSubscriptionResponder(resp *http.Response) (result DeviceSubscription, err error) {
                err = autorest.Respond(
                resp,
                azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNotFound),
                autorest.ByUnmarshallingJSON(&result),
                autorest.ByClosing())
                result.Response = autorest.Response{Response: resp}
                return
        }

    // GetCurrentConnectionStatus for a detailed description of each status, see
    // https://docs.microsoft.com/en-us/dotnet/api/microsoft.azure.devices.client.connectionstatus?view=azure-dotnet.
    func (client BaseClient) GetCurrentConnectionStatus(ctx context.Context, deviceID string) (result DeviceStatusResponseBody, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetCurrentConnectionStatus")
            defer func() {
                sc := -1
            if result.Response.Response != nil {
            sc = result.Response.Response.StatusCode
            }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
        req, err := client.GetCurrentConnectionStatusPreparer(ctx, deviceID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "bridge.BaseClient", "GetCurrentConnectionStatus", nil , "Failure preparing request")
        return
        }

            resp, err := client.GetCurrentConnectionStatusSender(req)
            if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "bridge.BaseClient", "GetCurrentConnectionStatus", resp, "Failure sending request")
            return
            }

            result, err = client.GetCurrentConnectionStatusResponder(resp)
            if err != nil {
            err = autorest.NewErrorWithError(err, "bridge.BaseClient", "GetCurrentConnectionStatus", resp, "Failure responding to request")
            return
            }

        return
    }

        // GetCurrentConnectionStatusPreparer prepares the GetCurrentConnectionStatus request.
        func (client BaseClient) GetCurrentConnectionStatusPreparer(ctx context.Context, deviceID string) (*http.Request, error) {
            pathParameters := map[string]interface{} {
            "deviceId": autorest.Encode("path",deviceID),
            }

        preparer := autorest.CreatePreparer(
    autorest.AsGet(),
    autorest.WithBaseURL(client.BaseURI),
    autorest.WithPathParameters("/devices/{deviceId}/ConnectionStatus",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetCurrentConnectionStatusSender sends the GetCurrentConnectionStatus request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetCurrentConnectionStatusSender(req *http.Request) (*http.Response, error) {
                    return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                    }

        // GetCurrentConnectionStatusResponder handles the response to the GetCurrentConnectionStatus request. The method always
        // closes the http.Response Body.
        func (client BaseClient) GetCurrentConnectionStatusResponder(resp *http.Response) (result DeviceStatusResponseBody, err error) {
                err = autorest.Respond(
                resp,
                azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNotFound),
                autorest.ByUnmarshallingJSON(&result),
                autorest.ByClosing())
                result.Response = autorest.Response{Response: resp}
                return
        }

    // GetDesiredPropertiesSubscription sends the get desired properties subscription request.
    func (client BaseClient) GetDesiredPropertiesSubscription(ctx context.Context, deviceID string) (result DeviceSubscriptionWithStatus, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetDesiredPropertiesSubscription")
            defer func() {
                sc := -1
            if result.Response.Response != nil {
            sc = result.Response.Response.StatusCode
            }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
        req, err := client.GetDesiredPropertiesSubscriptionPreparer(ctx, deviceID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "bridge.BaseClient", "GetDesiredPropertiesSubscription", nil , "Failure preparing request")
        return
        }

            resp, err := client.GetDesiredPropertiesSubscriptionSender(req)
            if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "bridge.BaseClient", "GetDesiredPropertiesSubscription", resp, "Failure sending request")
            return
            }

            result, err = client.GetDesiredPropertiesSubscriptionResponder(resp)
            if err != nil {
            err = autorest.NewErrorWithError(err, "bridge.BaseClient", "GetDesiredPropertiesSubscription", resp, "Failure responding to request")
            return
            }

        return
    }

        // GetDesiredPropertiesSubscriptionPreparer prepares the GetDesiredPropertiesSubscription request.
        func (client BaseClient) GetDesiredPropertiesSubscriptionPreparer(ctx context.Context, deviceID string) (*http.Request, error) {
            pathParameters := map[string]interface{} {
            "deviceId": autorest.Encode("path",deviceID),
            }

        preparer := autorest.CreatePreparer(
    autorest.AsGet(),
    autorest.WithBaseURL(client.BaseURI),
    autorest.WithPathParameters("/devices/{deviceId}/Twin/properties/desired/sub",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetDesiredPropertiesSubscriptionSender sends the GetDesiredPropertiesSubscription request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetDesiredPropertiesSubscriptionSender(req *http.Request) (*http.Response, error) {
                    return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                    }

        // GetDesiredPropertiesSubscriptionResponder handles the response to the GetDesiredPropertiesSubscription request. The method always
        // closes the http.Response Body.
        func (client BaseClient) GetDesiredPropertiesSubscriptionResponder(resp *http.Response) (result DeviceSubscriptionWithStatus, err error) {
                err = autorest.Respond(
                resp,
                azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNotFound),
                autorest.ByUnmarshallingJSON(&result),
                autorest.ByClosing())
                result.Response = autorest.Response{Response: resp}
                return
        }

    // GetMethodsSubscription sends the get methods subscription request.
    func (client BaseClient) GetMethodsSubscription(ctx context.Context, deviceID string) (result DeviceSubscriptionWithStatus, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetMethodsSubscription")
            defer func() {
                sc := -1
            if result.Response.Response != nil {
            sc = result.Response.Response.StatusCode
            }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
        req, err := client.GetMethodsSubscriptionPreparer(ctx, deviceID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "bridge.BaseClient", "GetMethodsSubscription", nil , "Failure preparing request")
        return
        }

            resp, err := client.GetMethodsSubscriptionSender(req)
            if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "bridge.BaseClient", "GetMethodsSubscription", resp, "Failure sending request")
            return
            }

            result, err = client.GetMethodsSubscriptionResponder(resp)
            if err != nil {
            err = autorest.NewErrorWithError(err, "bridge.BaseClient", "GetMethodsSubscription", resp, "Failure responding to request")
            return
            }

        return
    }

        // GetMethodsSubscriptionPreparer prepares the GetMethodsSubscription request.
        func (client BaseClient) GetMethodsSubscriptionPreparer(ctx context.Context, deviceID string) (*http.Request, error) {
            pathParameters := map[string]interface{} {
            "deviceId": autorest.Encode("path",deviceID),
            }

        preparer := autorest.CreatePreparer(
    autorest.AsGet(),
    autorest.WithBaseURL(client.BaseURI),
    autorest.WithPathParameters("/devices/{deviceId}/Methods/sub",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetMethodsSubscriptionSender sends the GetMethodsSubscription request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetMethodsSubscriptionSender(req *http.Request) (*http.Response, error) {
                    return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                    }

        // GetMethodsSubscriptionResponder handles the response to the GetMethodsSubscription request. The method always
        // closes the http.Response Body.
        func (client BaseClient) GetMethodsSubscriptionResponder(resp *http.Response) (result DeviceSubscriptionWithStatus, err error) {
                err = autorest.Respond(
                resp,
                azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNotFound),
                autorest.ByUnmarshallingJSON(&result),
                autorest.ByClosing())
                result.Response = autorest.Response{Response: resp}
                return
        }

    // GetTwin sends the get twin request.
    func (client BaseClient) GetTwin(ctx context.Context, deviceID string) (result GetTwinOKResponse, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetTwin")
            defer func() {
                sc := -1
            if result.Response.Response != nil {
            sc = result.Response.Response.StatusCode
            }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
        req, err := client.GetTwinPreparer(ctx, deviceID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "bridge.BaseClient", "GetTwin", nil , "Failure preparing request")
        return
        }

            resp, err := client.GetTwinSender(req)
            if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "bridge.BaseClient", "GetTwin", resp, "Failure sending request")
            return
            }

            result, err = client.GetTwinResponder(resp)
            if err != nil {
            err = autorest.NewErrorWithError(err, "bridge.BaseClient", "GetTwin", resp, "Failure responding to request")
            return
            }

        return
    }

        // GetTwinPreparer prepares the GetTwin request.
        func (client BaseClient) GetTwinPreparer(ctx context.Context, deviceID string) (*http.Request, error) {
            pathParameters := map[string]interface{} {
            "deviceId": autorest.Encode("path",deviceID),
            }

        preparer := autorest.CreatePreparer(
    autorest.AsGet(),
    autorest.WithBaseURL(client.BaseURI),
    autorest.WithPathParameters("/devices/{deviceId}/Twin",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetTwinSender sends the GetTwin request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetTwinSender(req *http.Request) (*http.Response, error) {
                    return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                    }

        // GetTwinResponder handles the response to the GetTwin request. The method always
        // closes the http.Response Body.
        func (client BaseClient) GetTwinResponder(resp *http.Response) (result GetTwinOKResponse, err error) {
                err = autorest.Respond(
                resp,
                azure.WithErrorUnlessStatusCode(http.StatusOK),
                autorest.ByUnmarshallingJSON(&result),
                autorest.ByClosing())
                result.Response = autorest.Response{Response: resp}
                return
        }

    // Register the registration result is internally cached to be used in future connections.
    // This route is only intended for ahead-of-time registration of devices with the bridge and assignment to a specific
    // model. To access all DPS registration features,
    // including sending custom registration payload and getting the assigned hub, please use the DPS REST API
    // (https://docs.microsoft.com/en-us/rest/api/iot-dps/).
    //
    // <b>NOTE:</b> DPS registration is a long-running operation, so calls to this route may take a long time to return. If
    // this is a concern, use the DPS REST API directly, which provides
    // support for long-running operation status lookup.
    func (client BaseClient) Register(ctx context.Context, deviceID string, body *RegistrationBody) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.Register")
            defer func() {
                sc := -1
            if result.Response != nil {
            sc = result.Response.StatusCode
            }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
        req, err := client.RegisterPreparer(ctx, deviceID, body)
        if err != nil {
        err = autorest.NewErrorWithError(err, "bridge.BaseClient", "Register", nil , "Failure preparing request")
        return
        }

            resp, err := client.RegisterSender(req)
            if err != nil {
            result.Response = resp
            err = autorest.NewErrorWithError(err, "bridge.BaseClient", "Register", resp, "Failure sending request")
            return
            }

            result, err = client.RegisterResponder(resp)
            if err != nil {
            err = autorest.NewErrorWithError(err, "bridge.BaseClient", "Register", resp, "Failure responding to request")
            return
            }

        return
    }

        // RegisterPreparer prepares the Register request.
        func (client BaseClient) RegisterPreparer(ctx context.Context, deviceID string, body *RegistrationBody) (*http.Request, error) {
            pathParameters := map[string]interface{} {
            "deviceId": autorest.Encode("path",deviceID),
            }

        preparer := autorest.CreatePreparer(
    autorest.AsContentType("application/json; charset=utf-8"),
    autorest.AsPost(),
    autorest.WithBaseURL(client.BaseURI),
    autorest.WithPathParameters("/devices/{deviceId}/Registration",pathParameters))
            if body != nil {
            preparer = autorest.DecoratePreparer(preparer,
            autorest.WithJSON(body))
            }
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // RegisterSender sends the Register request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) RegisterSender(req *http.Request) (*http.Response, error) {
                    return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                    }

        // RegisterResponder handles the response to the Register request. The method always
        // closes the http.Response Body.
        func (client BaseClient) RegisterResponder(resp *http.Response) (result autorest.Response, err error) {
                err = autorest.Respond(
                resp,
                azure.WithErrorUnlessStatusCode(http.StatusOK),
                autorest.ByClosing())
                result.Response = resp
                return
        }

    // Resync internally it forces the reconnection of the device if it's in a permanent failure state, due for instance
    // to:
    // - Bad credentials.
    // - Device was previously disabled in the cloud side.
    // - Automatic retries expired (e.g., due to a long period without network connectivity).
    func (client BaseClient) Resync(ctx context.Context, deviceID string) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.Resync")
            defer func() {
                sc := -1
            if result.Response != nil {
            sc = result.Response.StatusCode
            }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
        req, err := client.ResyncPreparer(ctx, deviceID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "bridge.BaseClient", "Resync", nil , "Failure preparing request")
        return
        }

            resp, err := client.ResyncSender(req)
            if err != nil {
            result.Response = resp
            err = autorest.NewErrorWithError(err, "bridge.BaseClient", "Resync", resp, "Failure sending request")
            return
            }

            result, err = client.ResyncResponder(resp)
            if err != nil {
            err = autorest.NewErrorWithError(err, "bridge.BaseClient", "Resync", resp, "Failure responding to request")
            return
            }

        return
    }

        // ResyncPreparer prepares the Resync request.
        func (client BaseClient) ResyncPreparer(ctx context.Context, deviceID string) (*http.Request, error) {
            pathParameters := map[string]interface{} {
            "deviceId": autorest.Encode("path",deviceID),
            }

        preparer := autorest.CreatePreparer(
    autorest.AsPost(),
    autorest.WithBaseURL(client.BaseURI),
    autorest.WithPathParameters("/devices/{deviceId}/Resync",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // ResyncSender sends the Resync request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) ResyncSender(req *http.Request) (*http.Response, error) {
                    return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                    }

        // ResyncResponder handles the response to the Resync request. The method always
        // closes the http.Response Body.
        func (client BaseClient) ResyncResponder(resp *http.Response) (result autorest.Response, err error) {
                err = autorest.Respond(
                resp,
                azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusAccepted),
                autorest.ByClosing())
                result.Response = resp
                return
        }

    // SendMessage example request:
    //
    // POST /devices/{deviceId}/messages/events
    // {
    // "data": {
    // "temperature": 4.8,
    // "humidity": 31
    // }
    // }
    // .
    func (client BaseClient) SendMessage(ctx context.Context, deviceID string, body *MessageBody) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.SendMessage")
            defer func() {
                sc := -1
            if result.Response != nil {
            sc = result.Response.StatusCode
            }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            if err := validation.Validate([]validation.Validation{
            { TargetValue: body,
             Constraints: []validation.Constraint{	{Target: "body", Name: validation.Null, Rule: false ,
            Chain: []validation.Constraint{	{Target: "body.Data", Name: validation.Null, Rule: true, Chain: nil },
            }}}}}); err != nil {
            return result, validation.NewError("bridge.BaseClient", "SendMessage", err.Error())
            }

            req, err := client.SendMessagePreparer(ctx, deviceID, body)
        if err != nil {
        err = autorest.NewErrorWithError(err, "bridge.BaseClient", "SendMessage", nil , "Failure preparing request")
        return
        }

            resp, err := client.SendMessageSender(req)
            if err != nil {
            result.Response = resp
            err = autorest.NewErrorWithError(err, "bridge.BaseClient", "SendMessage", resp, "Failure sending request")
            return
            }

            result, err = client.SendMessageResponder(resp)
            if err != nil {
            err = autorest.NewErrorWithError(err, "bridge.BaseClient", "SendMessage", resp, "Failure responding to request")
            return
            }

        return
    }

        // SendMessagePreparer prepares the SendMessage request.
        func (client BaseClient) SendMessagePreparer(ctx context.Context, deviceID string, body *MessageBody) (*http.Request, error) {
            pathParameters := map[string]interface{} {
            "deviceId": autorest.Encode("path",deviceID),
            }

        preparer := autorest.CreatePreparer(
    autorest.AsContentType("application/json; charset=utf-8"),
    autorest.AsPost(),
    autorest.WithBaseURL(client.BaseURI),
    autorest.WithPathParameters("/devices/{deviceId}/Messages/events",pathParameters))
            if body != nil {
            preparer = autorest.DecoratePreparer(preparer,
            autorest.WithJSON(body))
            }
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // SendMessageSender sends the SendMessage request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) SendMessageSender(req *http.Request) (*http.Response, error) {
                    return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                    }

        // SendMessageResponder handles the response to the SendMessage request. The method always
        // closes the http.Response Body.
        func (client BaseClient) SendMessageResponder(resp *http.Response) (result autorest.Response, err error) {
                err = autorest.Respond(
                resp,
                azure.WithErrorUnlessStatusCode(http.StatusOK),
                autorest.ByClosing())
                result.Response = resp
                return
        }

    // UpdateReportedProperties example request:
    //
    // PATCH /devices/{deviceId}/twin/properties/reported
    // {
    // "patch": {
    // "fanSpeed": 35,
    // "serial": "ABC"
    // }
    // }
    // .
    func (client BaseClient) UpdateReportedProperties(ctx context.Context, deviceID string, body *ReportedPropertiesPatch) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.UpdateReportedProperties")
            defer func() {
                sc := -1
            if result.Response != nil {
            sc = result.Response.StatusCode
            }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
        req, err := client.UpdateReportedPropertiesPreparer(ctx, deviceID, body)
        if err != nil {
        err = autorest.NewErrorWithError(err, "bridge.BaseClient", "UpdateReportedProperties", nil , "Failure preparing request")
        return
        }

            resp, err := client.UpdateReportedPropertiesSender(req)
            if err != nil {
            result.Response = resp
            err = autorest.NewErrorWithError(err, "bridge.BaseClient", "UpdateReportedProperties", resp, "Failure sending request")
            return
            }

            result, err = client.UpdateReportedPropertiesResponder(resp)
            if err != nil {
            err = autorest.NewErrorWithError(err, "bridge.BaseClient", "UpdateReportedProperties", resp, "Failure responding to request")
            return
            }

        return
    }

        // UpdateReportedPropertiesPreparer prepares the UpdateReportedProperties request.
        func (client BaseClient) UpdateReportedPropertiesPreparer(ctx context.Context, deviceID string, body *ReportedPropertiesPatch) (*http.Request, error) {
            pathParameters := map[string]interface{} {
            "deviceId": autorest.Encode("path",deviceID),
            }

        preparer := autorest.CreatePreparer(
    autorest.AsContentType("application/json; charset=utf-8"),
    autorest.AsPatch(),
    autorest.WithBaseURL(client.BaseURI),
    autorest.WithPathParameters("/devices/{deviceId}/Twin/properties/reported",pathParameters))
            if body != nil {
            preparer = autorest.DecoratePreparer(preparer,
            autorest.WithJSON(body))
            }
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // UpdateReportedPropertiesSender sends the UpdateReportedProperties request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) UpdateReportedPropertiesSender(req *http.Request) (*http.Response, error) {
                    return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                    }

        // UpdateReportedPropertiesResponder handles the response to the UpdateReportedProperties request. The method always
        // closes the http.Response Body.
        func (client BaseClient) UpdateReportedPropertiesResponder(resp *http.Response) (result autorest.Response, err error) {
                err = autorest.Respond(
                resp,
                azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNoContent),
                autorest.ByClosing())
                result.Response = resp
                return
        }

